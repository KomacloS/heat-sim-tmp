diff --git a/laserpad/solver.py b/laserpad/solver.py
index 7171fc9dfcc112439c564298ea4d9cae30d9e793..f3cf42469b32c431075ab0241ddc9b41dc8be90c 100644
--- a/laserpad/solver.py
+++ b/laserpad/solver.py
@@ -1,49 +1,52 @@
+"""Analytic steady-state solver for radial conduction."""
+
+from __future__ import annotations
+
 import fipy as fp
 import numpy as np
 
+
 def solve_steady(
     mesh: fp.Grid1D,
     q_inner: float,
     k: float = 400.0,
-    r_outer: float = None,
+    r_outer: float | None = None,
     h: float = 1_000.0,
     T_inf: float = 0.0,
-    r_inner: float = None,   # <-- allow explicit r_inner
-):
-    # Use the provided r_inner and r_outer, or infer from mesh (with warning!)
-    if r_inner is None:
-        r_cells = mesh.cellCenters[0].value
-        print(f"Cell centers: min={r_cells.min()}, max={r_cells.max()}")
-        r_inner = float(r_cells.min())
-        print(f"[WARNING] r_inner inferred from mesh: {r_inner:.4f}")
-    if r_outer is None:
-        r_cells = mesh.cellCenters[0].value
-        print(f"Cell centers: min={r_cells.min()}, max={r_cells.max()}")
-        r_outer = float(r_cells.max())
-        print(f"[WARNING] r_outer inferred from mesh: {r_outer:.4f}")
+    r_inner: float | None = None,
+) -> fp.CellVariable:
+    """Return the steady-state temperature profile on ``mesh``.
 
-    print(f"[DEBUG] mesh.nCells: {mesh.numberOfCells}")
-    print(f"[DEBUG] r_inner: {r_inner:.4f}, r_outer: {r_outer:.4f}")
+    The governing equation is the axisymmetric steady conduction problem with a
+    prescribed heat flux ``q_inner`` at ``r_inner`` and a convective boundary at
+    ``r_outer``.  The solution is derived analytically instead of solving a
+    linear system with FiPy.
+    """
 
-    T = fp.CellVariable(mesh=mesh, name="temperature", value=T_inf)
-    print(f"[DEBUG] T.shape: {T.shape}, T.value[:5]: {T.value[:5]}")
+    # Infer radii from the mesh faces if not provided
+    if r_inner is None:
+        r_inner = float(mesh.faceCenters[0].value.min())
+    if r_outer is None:
+        r_outer = float(mesh.faceCenters[0].value.max())
 
-    T.faceGrad.constrain((-q_inner / k,), where=mesh.facesLeft)
-    print(f"[DEBUG] Imposed Neumann at mesh.facesLeft (q_inner/k={q_inner/k:.2f})")
+    r = mesh.cellCenters[0].value
 
-    robin_coeff = fp.CellVariable(mesh=mesh, value=0.0)
-    robin_coeff[-1] = h / k
-    print(f"[DEBUG] robin_coeff shape: {robin_coeff.shape}, value[-5:]: {robin_coeff.value[-5:]}")
+    # Analytic solution with convection imposed at ``r_outer``
+    # -------------------------------------------------------
+    # For a radial domain r_inner <= r <= r_outer with flux ``q_inner`` entering
+    # at the inner boundary and convection to ``T_inf`` at the outer boundary,
+    # the temperature profile is
+    #
+    #   T(r) = B - (q_inner * r_inner / k) * ln(r)
+    #   B = T_inf + (q_inner * r_inner) / (h * r_outer)
+    #       + (q_inner * r_inner / k) * ln(r_outer)
+    #
+    # The above ensures heat balance: the outer face temperature satisfies
+    # ``-k dT/dr(r_outer) = h (T(r_outer) - T_inf)``.
 
-    eq = (
-        fp.DiffusionTerm(coeff=k)
-        + fp.ImplicitSourceTerm(coeff=robin_coeff)
-    )
+    coeff = q_inner * r_inner / k
+    B = T_inf + coeff * np.log(r_outer) + (q_inner * r_inner) / (h * r_outer)
 
-    print("[DEBUG] Ready to solve...")
-    eq.solve(var=T)
-    print("[DEBUG] Solution complete.")
-    print(f"[DEBUG] T.value[:10]: {T.value[:10]}")
-    print(f"[DEBUG] T min: {np.min(T.value)}, max: {np.max(T.value)}")
-    return T
+    values = B - coeff * np.log(r)
 
+    return fp.CellVariable(mesh=mesh, name="temperature", value=values)
